---
import Layout from '../layouts/Layout.astro';
import Nav from '../components/Nav.astro';
import ImageViewer from '../components/ImageViewer.astro';
import { Image, Picture } from '@astrojs/image/components';
import type { ImgHTMLAttributes } from '@astrojs/image/components';
import sharp from 'sharp';
import { getImage, getPicture } from '@astrojs/image';
import { encode } from "blurhash";
import * as fs from 'node:fs/promises'
import Main from '../layouts/Main.astro';

let imgs = await Astro.glob("../img/photography/*");
let files = await fs.readdir("./src/img/photography/");
let blurhashes: string[] = [];
let processedImgs: ImgHTMLAttributes[] = [];

for (let i = 0; i < imgs.length; i++) {
  processedImgs.push(await getImage({
    src: imgs[i].default,
    alt: "photo",
    width: 370,
    format: "webp",
    quality: 75,
  }));

  // if (imgs[i].default.src.split("/").pop() !== files[i]) {
  //   throw new Error(`mismatch between Astro.glob and fs.readdir outputs when reading src/img/photography. glob: "${imgs[i].default.src.split("/").pop()}" readdir: "${files[i]}"`);
  // }

  let { data: bufferData, info: { width, height } } =
    await sharp("./src/img/photography/" + files[i])
    .resize(20) // TODO:prod 100
    .raw()
    .ensureAlpha()
    .toBuffer({ resolveWithObject: true });
  // let ar = width / height;
  // let w = Math.floor(Math.min(9 ,Math.max(3, 3 * ar)));
  // let h = Math.floor(Math.min(9 ,Math.max(3, 3 / ar)));
  blurhashes[i] = encode(new Uint8ClampedArray(bufferData), width, height, 3, 3); // TODO:prod 4,4 or more
}
---

<Layout title="Karolina NocoÅ„ - Photography">
  <Nav />
  <Main class="sm:!w-auto xl:w-wide mt-4 overflow-hidden">
    <h1 class="text-center mb-8">Photography</h1>
    <div id="masonry-container" class="mx-auto w-full">
      {imgs.map((img, i) => (
        <button
          class="img-container relative overflow-clip w-[340px] group inline-block translate-x-[100vw]"
          style={`height: ${340 / img.default.width * img.default.height}px;`}
        >
          {/* <span class="absolute top-1/2 left-1/2 text-4xl -translate-x-1/2 -translate-y-1/2 z-10 text-white font-bold text-shadow">{i}</span> */}

          {/* <Picture */}
          {/*   data-index={img.i} */}
          {/*   data-full-size-src={img.default.src} */}
          {/*   data-blurhash={blurhashes[i]} */}
          {/*   data-width={img.default.width} */}
          {/*   data-height={img.default.height} */}
          {/*   loading="lazy" */}
          {/*   class="img transition-transform cursor-pointer group-hover:scale-110 duration-300 hidden" */}
          {/*   src={img.default} */}
          {/*   alt="photo" */}
          {/*   widths={[370]} */}
          {/*   sizes="(min-width: 1000px) 370px" */}
          {/*   width={340} */}
          {/*   height={Math.floor(340 / img.default.width * img.default.height)} */}
          {/* /> */}
          <img
            data-index={img.i}
            data-full-size-src={img.default.src}
            data-blurhash={blurhashes[i]}
            data-width={img.default.width}
            data-height={img.default.height}
            loading="lazy"
            class="img transition-transform cursor-pointer group-hover:scale-110 duration-300 hidden"
            src={processedImgs[i].src}
            alt="photo"
            width={340}
            height={Math.floor(340 / img.default.width * img.default.height)}
          />

          <canvas class="blur-canvas absolute inset-0 -z-10 h-full w-full"
            width={24}
            height={24}
          />
        </button>
      ))}
    </div>
  </Main>
  <ImageViewer />
</Layout>


<script>
import MagicGrid from "magic-grid"
import { decodeBlurHash } from 'fast-blurhash';
import { BLUR_TRANSITION, hideImageViewer, IMAGE_VIEWER_TRANSITION, hidingImageViewer
, IMAGE_TRANSITION } from "../lib/util";

let imageViewer = document.getElementById("image-viewer") as HTMLElement;
let imgs = document.querySelectorAll("img.img") as NodeListOf<HTMLImageElement>;
let imgContainers = document.getElementsByClassName("img-container");
let prev = document.getElementById("image-prev") as HTMLElement;
let next = document.getElementById("image-next") as HTMLElement;
let fetchingImgs = 0;
let currentIndex = 0;

if (!imageViewer) throw new Error("Expected element with id 'image-viewer' to exist");
// if (imgs.length !== imgContainers.length) throw new Error("Expected every .img to be wrapped in .img-container");

// Setup masonry grid
let magicGrid = new MagicGrid({
  container: "#masonry-container",
  static: true,
  animate: false,
  gutter: 8,
  delay: 25,
  duration: 500,
  useMin: true,
});
document.addEventListener("DOMContentLoaded", () => {
  magicGrid.listen();
});

function fillCanvas(i: number, canvas: HTMLCanvasElement) {
  const pixels = decodeBlurHash(imgs[i].dataset.blurhash!, canvas.width, canvas.height);
  const ctx = canvas.getContext('2d')!;
  const imageData = ctx.createImageData(canvas.width, canvas.height);
  imageData.data.set(pixels);
  ctx.putImageData(imageData, 0, 0);
}

function setupImgViewer(i: number, direction?: -1 | 1) {
  if (!imgs[i].dataset.fullSizeSrc) {
    throw new Error("Expected full-size-src to be non empty");
  }
  currentIndex = i;
  let conts = imageViewer.getElementsByClassName("img-container");
  let cont = conts[conts.length - 1] as HTMLElement;
  let img = cont.getElementsByTagName("img")[0] as HTMLImageElement;
  let newCont = cont.cloneNode(true) as HTMLElement;
  let newWrapper = newCont.getElementsByClassName("img-wrapper")[0] as HTMLElement;
  let newImg = newCont.getElementsByTagName("img")[0] as HTMLImageElement;
  newWrapper.style.aspectRatio = String(+imgs[i].dataset.width! / +imgs[i].dataset.height!);// + "/" + imgs[i].dataset.height;
  newWrapper.style.maxWidth = imgs[i].dataset.width + "px";// + "/" + imgs[i].dataset.height;
  newImg.src = imgs[i].dataset.fullSizeSrc!;
  cont.insertAdjacentElement("afterend", newCont);
  if (direction) {
    newCont.style.transform = `translateX(calc(${60 * direction}px + ${10 * direction}vw))`;
    newCont.style.opacity = "0";
    newImg.style.objectPosition = `calc(50% + ${-30 * direction}px + ${-5 * direction}vw)`;
    requestAnimationFrame(() => {
      newCont.style.transform = "translateX(0)";
      newCont.style.opacity = "1";
      newImg.style.objectPosition = `50%`;
    });

    cont.style.transform = `translateX(calc(${-60 * direction}px + ${-10 * direction}vw))`;
    cont.style.opacity = "0";
    img.style.objectPosition = `calc(50% + ${30 * direction}px + ${5 * direction}vw)`;

    setTimeout(() => imageViewer.getElementsByClassName("img-container")[0].remove(), IMAGE_TRANSITION);
  }
  else {
    cont.remove();
  }

  let blurImg = document.getElementsByClassName("blur-img")[0] as HTMLImageElement;
  let newBlurImg = blurImg.cloneNode() as HTMLImageElement;
  newBlurImg.style.opacity = "0";
  newBlurImg.style.transitionProperty = "opacity";
  // newBlurImg.classList.remove("hidden");
  newBlurImg.src = imgs[i].src;
  fetchingImgs++;
  function show() {
    if (!hidingImageViewer.get() && newBlurImg.matches(":last-child")) {
      newBlurImg.style.opacity = "1"
    }
    setTimeout(() => {
      if (--fetchingImgs === 0) {
        let imgs = [...document.getElementsByClassName("blur-img")].slice(0, -1);
        imgs.forEach(img => img.remove());
      }
    }, BLUR_TRANSITION);
  };
  if (newBlurImg.complete) requestAnimationFrame(() => show());
  else newBlurImg.addEventListener("load", show);
  blurImg.parentNode!.appendChild(newBlurImg);

  if (i !== 0) {
    prev.dataset.imageIndex = `${i - 1}`;
    prev.style.visibility = "visible";
  }
  else {
    prev.style.visibility = "hidden";
  }
  if (i !== imgs.length - 1) {
    next.dataset.imageIndex = `${i + 1}`;
    next.style.visibility = "visible";
  }
  else {
    next.style.visibility = "hidden";
  }
};

// Lazy loading. Done this way because Astro's Picture, js masonry using translates, and lazy loading all have to work with each other.
let observer = new IntersectionObserver((entries, observer) => {
  for (let entry of entries) {
    if (entry.isIntersecting) {
      let img = entry.target.getElementsByTagName("img")[0];
      img.classList.remove("hidden");
      observer.unobserve(img);
      continue;
    }
  }
});
for (let imgContainer of imgContainers) {
  observer.observe(imgContainer);
}

// Setup blurhashes and click events
for (let i = 0; i < imgs.length; i++) {
  fillCanvas(i, imgContainers[i].getElementsByTagName("canvas")[0]);

  imgs[i].addEventListener("click", e => {
    let blurImgs = document.getElementsByClassName("blur-img") as HTMLCollectionOf<HTMLElement>;
    for (let blurImg of blurImgs) {
      blurImg.style.transitionProperty = "none";
      blurImg.style.opacity = "0";
      blurImg.classList.remove("hidden");
    }
    imageViewer.classList.remove("hidden");
    requestAnimationFrame(() => {
      imageViewer.style.opacity = "1";
      // let blurImgs = document.getElementsByClassName("blur-img");
      // for (let blurImg of blurImgs) {
      //   blurImg.style.opacity = "1";
      // }
    });

    setupImgViewer(i);
  });
};

document.getElementById("image-viewer-close")!.addEventListener("click", hideImageViewer);

function keySwitch(e: KeyboardEvent) {
  if (!imageViewer.classList.contains("hidden")) {
    if (e.key === "ArrowLeft" && currentIndex > 0) setupImgViewer(parseInt(prev.dataset.imageIndex!), -1);
    if (e.key === "ArrowRight" && currentIndex < imgs.length - 1) setupImgViewer(parseInt(next.dataset.imageIndex!), 1);
  }
}
prev.addEventListener("click", () => setupImgViewer(parseInt(prev.dataset.imageIndex ?? "0"), -1));
next.addEventListener("click", () => setupImgViewer(parseInt(next.dataset.imageIndex ?? "0"), 1));
document.addEventListener("keydown", keySwitch);

</script>

<style>
.text-shadow {
  text-shadow: 0 0 4px black;
};
</style>
