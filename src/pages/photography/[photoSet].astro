---
import { getImage } from "@astrojs/image";
import path from "node:path";
import sharp from "sharp";
import Layout from "@layouts/Layout.astro";
import Nav from "@components/Nav.astro";
import ImageViewer from "@components/ImageViewer.astro";
import Main from "@layouts/Main.astro";
import { rgbaToThumbHash } from "thumbhash";
import { getAsset, toUrl } from "@lib/util";
import Link from "@components/Link.astro";
import { getCollection } from "astro:content";

interface Photo {
  src: string;
  alt: string;
}
interface PhotoSet {
  index: number;
  thumb: string;
  title: string;
  photos: Photo[];
}
interface Props {
  photoSet: PhotoSet;
  allSets: PhotoSet[];
}
interface MyImage {
  width: number;
  height: number;
  hash: string;
  src: string;
  fullSrc: string;
  alt: string;
}

export async function getStaticPaths() {
  let photoSetsRaw = await getCollection("photography");
  let photoSets = photoSetsRaw.map((photoSet) => photoSet.data);
  return photoSets.map((photoSet) => ({
    params: {
      photoSet: toUrl(photoSet.title),
    },
    props: { photoSet, allSets: photoSets },
  }));
}

const IMG_WIDTH = 320;

const { photoSet, allSets } = Astro.props;

let imgs: MyImage[] = [];

// Calculate blurhashes and transform images to smaller size
for (let { src, alt } of photoSet.photos) {
  const img = await getAsset(src);

  const { src: smallSrc } = await getImage({
    src: img.default.src,
    alt,
    width: IMG_WIDTH * 1.1,
    aspectRatio: img.default.width / img.default.height,
    format: "webp",
    quality: 90,
  });
  const { src: fullSrc } = await getImage({
    src: img.default.src,
    alt,
    width: img.default.width,
    height: img.default.height,
  });
  if (smallSrc == null || fullSrc == null) {
    throw new Error("Astro's getImage failed. src is not present.");
  }

  const {
    data: bufferData,
    info: { width: hashW, height: hashH },
  } = await sharp(path.join(".", src))
    .resize(20) // TODO:prod increase
    .raw()
    .ensureAlpha()
    .toBuffer({ resolveWithObject: true });

  const hash = Buffer.from(rgbaToThumbHash(hashW, hashH, bufferData)).toString("base64");
  imgs.push({ width: img.default.width, height: img.default.height, hash, src: smallSrc, fullSrc, alt });
}
---

<Layout>
  <Main class="sm:!w-auto xl:w-wide overflow-hidden">
    <Nav />
    <nav class="mt-12 lg:mt-8 mb-16">
      <ul class="flex flex-wrap justify-center">
        {
          allSets
            .sort((a, b) => a.index - b.index)
            .map((set) => (
              <li class="inline-block">
                <Link
                  href={"/photography/" + toUrl(set.title)}
                  class="px-4 pb-4 lg:px-2 group"
                  activeClass="!tracking-[0.55em] !font-bold px-6"
                >
                    {set.title}
                </Link>
              </li>
            ))
        }
      </ul>
    </nav>
    <div id="masonry-container" class="mx-auto w-full">
      {
        imgs.map((img, i) => (
          <button
            class="img-container relative overflow-clip max-w-full group inline-block translate-x-[100vw]"
            style={{
              width: `${IMG_WIDTH}px`,
              // height: `${(IMG_WIDTH / img.width) * img.height}px;`,
              aspectRatio: `${img.width} / ${img.height}`,
            }}
          >
            <img
              data-index={i}
              data-full-size-src={img.fullSrc}
              data-hash={img.hash}
              data-width={img.width}
              data-height={img.height}
              loading="lazy"
              class="img transition-transform cursor-pointer group-hover:scale-110 duration-300 hidden"
              src={img.src}
              alt={img.alt}
              width={IMG_WIDTH}
              height={Math.floor((IMG_WIDTH / img.width) * img.height)}
            />

            <canvas
              class="blur-canvas absolute inset-0 -z-10 h-full w-full"
              width={24}
              height={24}
            />
          </button>
        ))
      }
    </div>
  </Main>
  <ImageViewer />
</Layout>

<script>
import MagicGrid from "magic-grid";
import renderBlurhash from "@lib/renderBlurhash";

  let magicGrid = new MagicGrid({
    container: "#masonry-container",
    static: true,
    animate: false,
    gutter: 8,
    delay: 25,
    duration: 500,
    useMin: true,
  });
  document.addEventListener("DOMContentLoaded", () => {
    magicGrid.listen();
  });


  let imgContainers = document.getElementsByClassName("img-container");
  let imgs = document.querySelectorAll("img.img") as NodeListOf<HTMLImageElement>;

  // Lazy loading
  // Done this way because Astro's Images, js masonry using translates, and lazy loading all have to work with each other
  let observer = new IntersectionObserver((entries, observer) => {
    for (let entry of entries) {
      if (entry.isIntersecting) {
        let img = entry.target.getElementsByTagName("img")[0];
        img.classList.remove("hidden");
        observer.unobserve(img);
        continue;
      }
    }
  });

  for (let i = 0; i < imgContainers.length; i++) {
    renderBlurhash(imgs[i].dataset.hash!, imgContainers[i].getElementsByTagName("canvas")[0]);
    observer.observe(imgContainers[i]);
  }
</script>

<style>
  .text-shadow {
    text-shadow: 0 0 4px black;
  }
</style>
